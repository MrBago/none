\section{Dipy Utilities for Models}

\subsection{Gradient Table}
Dipy provides some tools for making the implementation of new models easier. The first of these tools is the \ttext{GradientTable} class. A gradient table object can be initialized from gradient table files, for example \ttext{bvec} and \ttext{bval} files commonly used in diffusion imaging, or simply an array of gradients by using the \ttext{gradient_table} factory function in \ttext{dipy.core.gradients}. A gradient table object allows a user to easily access different representations of gradient information. For example, the \ttext{bvals} attribute of the gradient table object exposes the diffusion weighting, commonly known as the b-value, of each gradient. Similarly, the \ttext{bvecs} attribute exposes the direction of each gradient as a unit vector and the \ttext{gradients} attribute exposes the total gradient vector.

\subsection{Spheres and Hemispheres}
Dipy uses the \ttext{Sphere} and \ttext{HemiSphere} classes as discrete representations of the unit sphere. The \ttext{HemiShere} class is a subclass of the \ttext{Sphere} class, provides the same interface, and can be used anywhere Dipy requires a \ttext{Sphere} instance.  Both \ttext{Sphere} and \ttext{HemiSphere} objects consist primarily of a set of dispersed points, or vertices, on the unit sphere. The \ttext{Sphere} class also provides \ttext{faces} and \ttext{edges} attributes which provide neighbor information about the vertices of the sphere. Each face of the \ttext{Sphere} is triplet of integers between 0 and N - 1, where N is the number of points of the \ttext{Sphere}. The faces, taken together, make up a mesh surface which approximates a sphere. Each edge of a \ttext{Sphere} is a pair of integers between 0 and N - 1 and represents two neighbor points. Each point has a neighbor relationship with the closest points to itself. This neighbor relationship is important for peak finding and fiber tracking applications.

Though the \ttext{Sphere} and \ttext{HemiSphere} classes are similar, there is one key difference. The \ttext{HemiSphere} class incorporates an understanding of antipodal symmetry into its definition of distance between points. On the surface of the sphere, we can define a distance function between two points, $\vec{v_1}$ and $\vec{v_2}$ as $d(\vec{v_1}, \vec{v_2}) = cos^{-1}(\vec{v_1} \cdot \vec{v_2})$. This is the intuitive definition of distance that is familiar to most people. Under this definition, the points $\vec{v}$ and $-\vec{v}$ are separated by a distance of $\pi$, the furthest possible distance between two points on a unit sphere. In the context of diffusion imaging, we want to be able to represent antipodally symmetric distance function where the points $v$ and $-v$ are in effect the same point. To represent this symmetry, we can define a new distance function on the sphere, $d(\vec{v_1}, \vec{v_2}) = cos^{-1}(|\vec{v_1} \cdot \vec{v_2}|)$. By using this new distance function, the \ttext{HemiSphere} class is able to effectively represent an antipodally symmetric sphere with half as many points, without loosing important neighbor relations. While it is redundant to use a full \ttext{Sphere} to represent an antipodally symmetric spherical surface, sometimes a full \ttext{Sphere} object can still be useful, for example for visualizing spherical functions without discontinuities. The \ttext{HemiSphere} class provides a \ttext{mirror} method to duplicate and project the vertices of a \ttext{HemiSphere} onto a full sphere. Figures \ref{fig:hemiSphere} and \ref{fig:fullSphere} show a 3d rendering of a \ttext{HemiSphere} and its mirror respectively.

Dipy provides a \ttext{default_sphere} object, which is an instance of \ttext{HemiSphere}, in \ttext{dipy.data}. The \ttext{default_sphere} consists of 362 vertices dispersed on a unit hemisphere. We've found that this number of points provides a good balance between coverage and computational performance.
